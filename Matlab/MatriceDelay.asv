function main
numb_neurons = 10;
numb_camp = 1200;
f=10;
threshold = 0.017;


start_all = tic;
%Lettura in input del matrice degli spikes
start_input = tic;
path = pwd;
path = path (1:end-7);
file_name = strcat(path,'\GitHub\HPPS_NN\HPPS_inputData.txt');
f2 = fopen (file_name, 'r');
str = '';
for l = 1:numb_camp
    str =  strcat(str, '%g ');
end
s1 = fscanf(f2, str ,[numb_camp numb_neurons]);
s = s1;
fclose(f2);
t_input = toc(start_input)

start_delay = tic;
t_iteration_delay = zeros(numb_neurons, numb_neurons);
delays=zeros(numb_camp,numb_neurons,numb_neurons); %crea una matrice di 0 3000*40*40
for i=1:numb_neurons
    i
  for j=1:numb_neurons
    t1 = tic;
    qi=find(s(:,i)==1); %estrae i time degli spike di i
    qj=find(s(:,j)==1); %estrae i time degli spike di j
    for k=1:length(qi)
      q=qj-qi(k);   %differenza degli skipe di j con gli spike di i
      q2=q(find(q>=0)); %filtro q per prendere solo i maggiori
      if length(q2)>0
        h=histc(q2,0:numb_camp);
        delays(:,i,j)=delays(:,i,j)+reshape(h(1:numb_camp),numb_camp,1);
      end
    t_iteration_delay(i,j) = toc(t1);
    end
  end
end
t_delay = toc(start_delay)

start_normal = tic;
for i=1:numb_neurons
  for j=1:numb_neurons
    delaysn(:,i,j) = delays(:,i,j)./sum(delays(:,i,j));   %delay normalizzato sulla somma totale dei delay i,j
  end
end
t_normal = toc(start_normal)

start_compress = tic;
d1=zeros(floor(length(delaysn)./f)+1,numb_neurons,numb_neurons);    %è come se andasse a comprimere la matrice di partenza lungo l'asse del tempo
for i=1:floor(length(delaysn)./f)
  d1(i,:,:)=sum(delaysn(((i-1)*f)+1:i*f, :, :),1);  %1 indica che la somma è fatta lungo la prima dimensione
end
if i<length(delaysn)./f %gestisce la posizione 501
  i=i+1;
  d1(i,:)=sum(delaysn((i-1)*f+1:end,:,:),1);
end
m_d1=squeeze(max(d1,[],1)); %ritorna il valore massimo per ogni riga lungo la prima dimensione

m_delaysn=squeeze(max(delaysn,[],1));
t_compress = toc(start_compress)


t_all = toc(start_all)

mean_iteration_time = mean (mean (t_iteration_delay))
%save fdelays01 fdelays fdelaysn m_fdelaysn m_fd1 fd1

d1_100=d1(1:101,:,:);
    for i=1:numb_neurons
      for j=1:numb_neurons
        d1_100n(:,i,j)=d1_100(:,i,j)./sum(d1_100(:,i,j));
      end
    end

%Seconda parte
conn=zeros(numb_neurons,numb_neurons);
  conn_cum=zeros(numb_neurons,numb_neurons);
  conn_time=inf*ones(numb_neurons,numb_neurons);
  for i=1:numb_neurons
    for j=1:numb_neurons
      q=find(d1_100n(:,i,j)>=threshold);
      if (not(isempty(q)))
        conn(i,j)=d1_100n(q(1),i,j);
        conn_cum(i,j)=sum(d1_100n(q,i,j)); %somma dei camponamenti sopra la soglia
        conn_time(i,j)=q(1); %q(1) primo istante di tempo sopra la soglia
      end
    end
  end
  %toglie i casi 1-1 2-2 3-3 4-4
  conn_n = conn - diag(diag(conn)); %ok solo per matrici quadrate
  conn_cum_n = conn_cum - diag(diag(conn_cum));
  
edges = zeros(numb_neurons, numb_neurons);  
edges = conn_cum_n;

nn=find([ max(edges,[],2)+max(edges,[],1)']>0)
ne=sum(sum(edges>0))

nnodes=nn;
edgesR=zeros(numb_neurons);
xi=0;
x=[];
for i=nnodes'
  for j=nnodes'
    if (i~=j)
      xi=xi+1;
      x(xi,:)=[i j];
    end
  end
end

for i=1:ne
  xx=ceil(rand*xi);
  q=x(xx,:);
  edgesR(q(1),q(2))=1;
  x=x([1:xx-1 xx+1:end],:);
  xi=xi-1;
end
end

function my_save(string_name, matrix , num_stamp , n_neur)
path = pwd;
path = path (1:end-7);
file_name = strcat(path,'\GitHub\HPPS_NN\',string_name,'.txt');
f1 = fopen (file_name, 'w');
for i = 1:n_neur
        for j = 1:n_neur
          fprintf(f1, 'coppia %g %g \n', i,j) ;
          for k = 1:num_stamp
            fprintf(f1, '%g ', matrix(k,i,j));
          end
          fprintf(f1, '\n');
        end
end
fclose(f1);
end
